#!/bin/bash
#
# Copyright (C) 2019 Philippe Proulx <pproulx@efficios.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; only version 2
# of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# This test validates that a `src.ctf.fs` component successfully reads
# specific CTF traces and creates the expected messages.
#
# Such CTF traces to open either exist (in `tests/ctf-traces/succeed`)
# or are generated by this test using local trace generators.

SH_TAP=1

if [ "x${BT_TESTS_SRCDIR:-}" != "x" ]; then
	UTILSSH="$BT_TESTS_SRCDIR/utils/utils.sh"
else
	UTILSSH="$(dirname "$0")/../../utils/utils.sh"
fi

# shellcheck source=../../utils/utils.sh
source "$UTILSSH"

function cleanup ()
{
	# Disable trap for SIGTERM since the following kill to the
	# pidgroup will be SIGTERM. Otherwise it loops.
	# The '-' before the pid number ($$) indicates 'kill' to signal the
	# whole process group.
	trap - SIGTERM && kill -- -$$
}

# Ensure that background child jobs are killed on SIGINT/SIGTERM
trap cleanup SIGINT SIGTERM

this_dir_relative="plugins/src.ctf.lttng-live"
test_data_dir="$BT_TESTS_DATADIR/$this_dir_relative"
trace_dir="$BT_CTF_TRACES_PATH/succeed"

if [ "$BT_OS_TYPE" = "mingw" ]; then
	# Same as the above, but in Windows form (C:\foo\bar) instead of Unix form
	# (/c/foo/bar).
	trace_dir_native=$(cygpath -w "${trace_dir}")
else
	trace_dir_native="${trace_dir}"
fi

lttng_live_server() {
	local port_file="$1"
	local pid_file="$2"
	local retcode_file="$3"
	local server_args="$4"
	local server_script="$test_data_dir/lttng_live_server.py"

	# start server
	echo "$server_args" | xargs "$BT_TESTS_PYTHON_BIN" "$server_script" --port-file "$port_file" &

	# write PID to file
	echo $! > "$pid_file"

	# wait for server to exit
	wait

	# write return code to file
	echo $? > "$retcode_file"
}

kill_lttng_live_server() {
	local pid_file="$1"

	if [ ! -s "$pid_file" ]; then
		return
	fi

	kill -9 "$(cat "$pid_file")"
}

get_cli_output_with_lttng_live_server() {
	local cli_args_template="$1"
	local server_args="$2"
	local cli_stdout_file="$3"
	local cli_stderr_file="$4"
	local port_file="$5"

	local i
	local ret
	local port
	local cli_args
	local server_pid_file
	local server_retcode_file

	server_pid_file="$(mktemp -t test_live_server_pid.XXXXXX)"
	server_retcode_file="$(mktemp -t test_live_server_ret.XXXXX)"

	diag "Starting LTTng live server mockup"

	# This starts the server, which eventually writes its listening
	# port number to the `$port_file` file. The lttng_live_server()
	# function itself writes the server's PID to the
	# `$server_pid_file` file. When the server exits,
	# lttng_live_server() writes its return code to the
	# `$server_retcode_file` file.
	lttng_live_server "$port_file" "$server_pid_file" \
		"$server_retcode_file" "$server_args" &

	# Get port number
	i=0
	while [ ! -s "$port_file" ]; do
		sleep .1

		# Timeout of 30 seconds
		if [ "$i" -eq "300" ]; then
			# too long, kill it
			kill_lttng_live_server "$server_pid_file"
			wait
			rm -f "$server_pid_file"
			rm -f "$server_retcode_file"
			return 1
		fi

		i=$((i + 1))
	done

	port=$(<"$port_file")

	diag "LTTng live port is $port"

	cli_args=${cli_args_template//@PORT@/$port}

	diag "Running CLI: 'babeltrace2 $cli_args'"
	if ! "$BT_TESTS_BT2_BIN" $cli_args 1>"$cli_stdout_file" 2>"$cli_stderr_file"; then
		# CLI failed: cancel everything else
		kill_lttng_live_server "$server_pid_file"
		wait
		rm -f "$server_pid_file"
		rm -f "$server_retcode_file"
		return 1
	fi

	# get server's return code
	i=0
	while [ ! -s "$server_retcode_file" ]; do
		sleep .1

		# Timeout of 30 seconds
		if [ "$i" -eq "300" ]; then
			# too long, kill it
			kill_lttng_live_server "$server_pid_file"
			wait
			rm -f "$server_pid_file"
			rm -f "$server_retcode_file"
			return 1
		fi

		i=$((i + 1))
	done

	wait

	ret=$(<"$server_retcode_file")

	rm -f "$server_pid_file"
	rm -f "$server_retcode_file"
	return "$ret"
}

run_test() {
	local test_text="$1"
	local cli_args_template="$2"
	local server_args="$3"
	local expected_stdout="$4"
	local expected_stderr="$5"

	local cli_stderr
	local cli_stdout
	local port_file
        local port

	cli_stderr="$(mktemp -t test_live_stderr.XXXXXX)"
	cli_stdout="$(mktemp -t test_live_stdout.XXXXXX)"
	port_file="$(mktemp -t test_live_server_port.XXXXXX)"

	get_cli_output_with_lttng_live_server "$cli_args_template" "$server_args" "$cli_stdout" "$cli_stderr" "$port_file"
	port=$(<"$port_file")

	bt_diff "$expected_stdout" "$cli_stdout"
	ok $? "$test_text - stdout"
	bt_diff "$expected_stderr" "$cli_stderr"
	ok $? "$test_text - stderr"

	rm -f "$cli_stderr"
	rm -f "$cli_stdout"
	rm -f "$port_file"
}

test_list_sessions() {
	# Test the basic listing of sessions.
	# Ensure that a multi-domain trace is seen as a single session.
	# run_test() is not used here because the port is needed to craft the
	# expected output.

	local port
	local port_file
	local tmp_stdout_expected
	local template_expected

	local test_text="CLI prints the expected session list"
	local cli_args_template="-i lttng-live net://localhost:@PORT@"
	local server_args="'multi-domains,0,hostname,1,0,${trace_dir_native}/multi-domains/ust/' 'multi-domains,1,hostname,1,0,${trace_dir_native}/multi-domains/kernel/' 'trace-with-index,2,hostname,1,0,${trace_dir_native}/trace-with-index/' "

	template_expected=$(<"$test_data_dir/cli-list-sessions.expect")
	cli_stderr="$(mktemp -t test_live_list_sessions_stderr.XXXXXX)"
	cli_stdout="$(mktemp -t test_live_list_sessions_stdout.XXXXXX)"
	empty_file="$(mktemp -t test_live_list_sessions_empty.XXXXXX)"
	port_file="$(mktemp -t test_live_list_sessions_server_port.XXXXXX)"
	tmp_stdout_expected="$(mktemp -t test_live_list_sessions_stdout_expected.XXXXXX)"

	get_cli_output_with_lttng_live_server "$cli_args_template" "$server_args" "$cli_stdout" "$cli_stderr" "$port_file"
	port=$(<"$port_file")

	# Craft the expected output. This is necessary since the port number
	# (random) of a "relayd" is present in the output.
	template_expected=${template_expected//@PORT@/$port}

	echo "$template_expected" > "$tmp_stdout_expected"

	bt_diff "$tmp_stdout_expected" "$cli_stdout"
	ok $? "$test_text - stdout"
	bt_diff "$empty_file" "$cli_stderr"
	ok $? "$test_text - stderr"

	rm -f "$cli_stderr"
	rm -f "$cli_stdout"
	rm -f "$empty_file"
	rm -f "$port_file"
	rm -f "$tmp_stdout_expected"
}

test_base() {
	# Attach and consume data from a multi packets ust session with no
	# discarded events.
	local test_text="CLI attach and fetch from single-domains session - no discarded events"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/trace-with-index -c sink.text.details"
	local server_args="'trace-with-index,0,hostname,1,0,${trace_dir_native}/trace-with-index/'"
	local expected_stdout="${test_data_dir}/cli-base.expect"
	local expected_stderr

	# Empty file for stderr expected
	expected_stderr="$(mktemp -t test_live_base_stderr_expected.XXXXXX)"

	run_test "$test_text" "$cli_args_template" "$server_args" "$expected_stdout" "$expected_stderr"

	rm -f "$expected_stderr"
}

test_multi_domains() {
	# Attach and consume data from a multi-domains session with discarded
	# events.
	local test_text="CLI attach and fetch from multi-domains session - discarded events"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/multi-domains -c sink.text.details"
	local server_args="'multi-domains,0,hostname,1,0,${trace_dir_native}/multi-domains/kernel/,${trace_dir_native}/multi-domains/ust/'"
	local expected_stdout="${test_data_dir}/cli-multi-domains.expect"
	local expected_stderr

	# Empty file for stderr expected
	expected_stderr="$(mktemp -t test_live_multi_domains_stderr_expected.XXXXXX)"

	run_test "$test_text" "$cli_args_template" "$server_args" "$expected_stdout" "$expected_stderr"

	rm -f "$expected_stderr"
}

test_rate_limited() {
	# Attach and consume data from a multi packets ust session with no
	# discarded events. Enforce a server side limit on the stream data
	# requests size. Ensure that babeltrace respect the returned size and that
	# many requests per packet works as expected.
	# The packet size of the test trace is 4k. Limit requests to 1k.
	local test_text="CLI many requests per packet"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/trace-with-index -c sink.text.details"
	local server_args="--max-query-data-response-size 1024 'trace-with-index,0,hostname,1,0,${trace_dir_native}/trace-with-index/'"
	local expected_stdout="${test_data_dir}/cli-base.expect"
	local expected_stderr

	# Empty file for stderr expected
	expected_stderr="$(mktemp -t test_live_rate_limited_stderr_expected.XXXXXX)"

	run_test "$test_text" "$cli_args_template" "$server_args" "$expected_stdout" "$expected_stderr"

	rm -f "$expected_stderr"
}

test_compare_to_ctf_fs() {
	# Compare the details text sink or ctf.fs and ctf.lttng-live to ensure
	# that the trace is parsed the same way.
	# Do the same with the session swapped on the relayd side. This validate
	# that ordering is consistent between live and ctf fs.
	local test_text="CLI src.ctf.fs vs src.ctf.lttng-live"
	local cli_args_template="-i lttng-live net://localhost:@PORT@/host/hostname/multi-domains -c sink.text.details --params with-trace-name=false,with-stream-name=false"
	local server_args="'multi-domains,0,hostname,1,0,${trace_dir_native}/multi-domains/kernel/' 'multi-domains,1,hostname,1,0,${trace_dir_native}/multi-domains/ust/'"
	local server_args_inverse="'multi-domains,0,hostname,1,0,${trace_dir_native}/multi-domains/ust/' 'multi-domains,1,hostname,1,0,${trace_dir_native}/multi-domains/kernel/'"
	local expected_stdout
	local expected_stderr

	expected_stdout="$(mktemp -t test_live_compare_stdout_expected.XXXXXX)"
	expected_stderr="$(mktemp -t test_live_compare_stderr_expected.XXXXXX)"

	bt_cli "$expected_stdout" "$expected_stderr" "${trace_dir}/multi-domains" -c sink.text.details --params "with-trace-name=false,with-stream-name=false"
	bt_remove_cr "${expected_stdout}"
	bt_remove_cr "${expected_stderr}"
	run_test "$test_text" "$cli_args_template" "$server_args" "$expected_stdout" "$expected_stderr"
	diag "Inverse session order from lttng-relayd"
	run_test "$test_text" "$cli_args_template" "$server_args_inverse" "$expected_stdout" "$expected_stderr"

	rm -f "$expected_stdout"
	rm -f "$expected_stderr"
}

plan_tests 12

test_list_sessions
test_base
test_multi_domains
test_rate_limited
test_compare_to_ctf_fs
